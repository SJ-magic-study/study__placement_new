/************************************************************
[placement new]

description
	引数付きコンストラクタの配列がメンバにある場合に、このメンバに引数を渡す方法が、C++には用意されていない。
	
	まず、MyClassにデフォルトコンストラクタを作ります。
	「いや、でも引数でしか値を渡せない事があるじゃない（怒）」と思われるかもしれません。
	その通りなんです。そういうので良くあるのがコンストラクタの引数でIDirect3DDevice9のような描画デバイスを渡すクラスです。
	ここを逃すとこのデバイスを渡す方法が無くなってしまいます。
	
	そこで、placement newを使います。
	placement newは通常のnewと違いヒープ領域からメモリを確保しません。
	プログラマが予め確保したメモリに対して生成したオブジェクトを流し込んでくれます。
	
	また、
	newと聞くと対応するdeleteを考えてしまうのですが、実はplacement newはdeleteする必要がありません。
	と言うのもplacement newは単に指定のメモリにオブジェクトを置くだけで、それ自身がメモリを確保するわけではないからです。


参考URL
	http://marupeke296.com/TIPS_No13_ClassArrayInitialize.html
************************************************************/



/************************************************************
************************************************************/
#include <stdio.h>

/************************************************************
************************************************************/
#include <new> // need this

/************************************************************
************************************************************/
enum{
	NUM = 5,
};

/************************************************************
************************************************************/
class MyClass {
private:
   int m_Value;
   
public:
   MyClass() : m_Value( 0 )
   {
   }

   MyClass( int value ) : m_Value( value )
   {
   }
   
   void print()
   {
	   printf("%d\n", m_Value);
   }
};

class World {
private:
   MyClass object[ NUM ];
   
public:
   World() {
	  // 配列をplacement newを使って初期化する
	  for ( int i = 0; i < NUM; i++ ) {
		 new( object + i ) MyClass( i );
	  }
   }
   
   void print()
   {
	   for(int i = 0; i < NUM; i++){
		   object[i].print();
	   }
   }
};


/************************************************************
************************************************************/
int main(int argc, const char *argv[])
{
	World world;
	
	world.print();
	
	return 0;
}



